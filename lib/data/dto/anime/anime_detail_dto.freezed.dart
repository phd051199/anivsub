// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'anime_detail_dto.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AnimeDetailDTO _$AnimeDetailDTOFromJson(Map<String, dynamic> json) {
  return _AnimeDetailDTO.fromJson(json);
}

/// @nodoc
mixin _$AnimeDetailDTO {
  String get name => throw _privateConstructorUsedError;
  String get othername => throw _privateConstructorUsedError;
  String get image => throw _privateConstructorUsedError;
  String get poster => throw _privateConstructorUsedError;
  String? get pathToView => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  double get rate => throw _privateConstructorUsedError;
  int get countRate => throw _privateConstructorUsedError;
  String get duration => throw _privateConstructorUsedError;
  int get yearOf => throw _privateConstructorUsedError;
  int get views => throw _privateConstructorUsedError;
  List<Anchor> get season => throw _privateConstructorUsedError;
  List<Anchor> get genre => throw _privateConstructorUsedError;
  String get quality => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  List<Anchor> get authors => throw _privateConstructorUsedError;
  List<Anchor> get countries => throw _privateConstructorUsedError;
  int get follows => throw _privateConstructorUsedError;
  String get language => throw _privateConstructorUsedError;
  String get studio => throw _privateConstructorUsedError;
  Anchor? get seasonOf => throw _privateConstructorUsedError;
  String? get trailer => throw _privateConstructorUsedError;
  List<AnimeDataResponseDTO> get toPut => throw _privateConstructorUsedError;
  String? get schedule => throw _privateConstructorUsedError;

  /// Serializes this AnimeDetailDTO to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AnimeDetailDTO
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AnimeDetailDTOCopyWith<AnimeDetailDTO> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnimeDetailDTOCopyWith<$Res> {
  factory $AnimeDetailDTOCopyWith(
          AnimeDetailDTO value, $Res Function(AnimeDetailDTO) then) =
      _$AnimeDetailDTOCopyWithImpl<$Res, AnimeDetailDTO>;
  @useResult
  $Res call(
      {String name,
      String othername,
      String image,
      String poster,
      String? pathToView,
      String description,
      double rate,
      int countRate,
      String duration,
      int yearOf,
      int views,
      List<Anchor> season,
      List<Anchor> genre,
      String quality,
      String status,
      List<Anchor> authors,
      List<Anchor> countries,
      int follows,
      String language,
      String studio,
      Anchor? seasonOf,
      String? trailer,
      List<AnimeDataResponseDTO> toPut,
      String? schedule});

  $AnchorCopyWith<$Res>? get seasonOf;
}

/// @nodoc
class _$AnimeDetailDTOCopyWithImpl<$Res, $Val extends AnimeDetailDTO>
    implements $AnimeDetailDTOCopyWith<$Res> {
  _$AnimeDetailDTOCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnimeDetailDTO
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? othername = null,
    Object? image = null,
    Object? poster = null,
    Object? pathToView = freezed,
    Object? description = null,
    Object? rate = null,
    Object? countRate = null,
    Object? duration = null,
    Object? yearOf = null,
    Object? views = null,
    Object? season = null,
    Object? genre = null,
    Object? quality = null,
    Object? status = null,
    Object? authors = null,
    Object? countries = null,
    Object? follows = null,
    Object? language = null,
    Object? studio = null,
    Object? seasonOf = freezed,
    Object? trailer = freezed,
    Object? toPut = null,
    Object? schedule = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      othername: null == othername
          ? _value.othername
          : othername // ignore: cast_nullable_to_non_nullable
              as String,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
      poster: null == poster
          ? _value.poster
          : poster // ignore: cast_nullable_to_non_nullable
              as String,
      pathToView: freezed == pathToView
          ? _value.pathToView
          : pathToView // ignore: cast_nullable_to_non_nullable
              as String?,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as double,
      countRate: null == countRate
          ? _value.countRate
          : countRate // ignore: cast_nullable_to_non_nullable
              as int,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as String,
      yearOf: null == yearOf
          ? _value.yearOf
          : yearOf // ignore: cast_nullable_to_non_nullable
              as int,
      views: null == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int,
      season: null == season
          ? _value.season
          : season // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      genre: null == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      authors: null == authors
          ? _value.authors
          : authors // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      countries: null == countries
          ? _value.countries
          : countries // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      follows: null == follows
          ? _value.follows
          : follows // ignore: cast_nullable_to_non_nullable
              as int,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String,
      studio: null == studio
          ? _value.studio
          : studio // ignore: cast_nullable_to_non_nullable
              as String,
      seasonOf: freezed == seasonOf
          ? _value.seasonOf
          : seasonOf // ignore: cast_nullable_to_non_nullable
              as Anchor?,
      trailer: freezed == trailer
          ? _value.trailer
          : trailer // ignore: cast_nullable_to_non_nullable
              as String?,
      toPut: null == toPut
          ? _value.toPut
          : toPut // ignore: cast_nullable_to_non_nullable
              as List<AnimeDataResponseDTO>,
      schedule: freezed == schedule
          ? _value.schedule
          : schedule // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of AnimeDetailDTO
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AnchorCopyWith<$Res>? get seasonOf {
    if (_value.seasonOf == null) {
      return null;
    }

    return $AnchorCopyWith<$Res>(_value.seasonOf!, (value) {
      return _then(_value.copyWith(seasonOf: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AnimeDetailDTOImplCopyWith<$Res>
    implements $AnimeDetailDTOCopyWith<$Res> {
  factory _$$AnimeDetailDTOImplCopyWith(_$AnimeDetailDTOImpl value,
          $Res Function(_$AnimeDetailDTOImpl) then) =
      __$$AnimeDetailDTOImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String othername,
      String image,
      String poster,
      String? pathToView,
      String description,
      double rate,
      int countRate,
      String duration,
      int yearOf,
      int views,
      List<Anchor> season,
      List<Anchor> genre,
      String quality,
      String status,
      List<Anchor> authors,
      List<Anchor> countries,
      int follows,
      String language,
      String studio,
      Anchor? seasonOf,
      String? trailer,
      List<AnimeDataResponseDTO> toPut,
      String? schedule});

  @override
  $AnchorCopyWith<$Res>? get seasonOf;
}

/// @nodoc
class __$$AnimeDetailDTOImplCopyWithImpl<$Res>
    extends _$AnimeDetailDTOCopyWithImpl<$Res, _$AnimeDetailDTOImpl>
    implements _$$AnimeDetailDTOImplCopyWith<$Res> {
  __$$AnimeDetailDTOImplCopyWithImpl(
      _$AnimeDetailDTOImpl _value, $Res Function(_$AnimeDetailDTOImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnimeDetailDTO
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? othername = null,
    Object? image = null,
    Object? poster = null,
    Object? pathToView = freezed,
    Object? description = null,
    Object? rate = null,
    Object? countRate = null,
    Object? duration = null,
    Object? yearOf = null,
    Object? views = null,
    Object? season = null,
    Object? genre = null,
    Object? quality = null,
    Object? status = null,
    Object? authors = null,
    Object? countries = null,
    Object? follows = null,
    Object? language = null,
    Object? studio = null,
    Object? seasonOf = freezed,
    Object? trailer = freezed,
    Object? toPut = null,
    Object? schedule = freezed,
  }) {
    return _then(_$AnimeDetailDTOImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      othername: null == othername
          ? _value.othername
          : othername // ignore: cast_nullable_to_non_nullable
              as String,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
      poster: null == poster
          ? _value.poster
          : poster // ignore: cast_nullable_to_non_nullable
              as String,
      pathToView: freezed == pathToView
          ? _value.pathToView
          : pathToView // ignore: cast_nullable_to_non_nullable
              as String?,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as double,
      countRate: null == countRate
          ? _value.countRate
          : countRate // ignore: cast_nullable_to_non_nullable
              as int,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as String,
      yearOf: null == yearOf
          ? _value.yearOf
          : yearOf // ignore: cast_nullable_to_non_nullable
              as int,
      views: null == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int,
      season: null == season
          ? _value._season
          : season // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      genre: null == genre
          ? _value._genre
          : genre // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      authors: null == authors
          ? _value._authors
          : authors // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      countries: null == countries
          ? _value._countries
          : countries // ignore: cast_nullable_to_non_nullable
              as List<Anchor>,
      follows: null == follows
          ? _value.follows
          : follows // ignore: cast_nullable_to_non_nullable
              as int,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String,
      studio: null == studio
          ? _value.studio
          : studio // ignore: cast_nullable_to_non_nullable
              as String,
      seasonOf: freezed == seasonOf
          ? _value.seasonOf
          : seasonOf // ignore: cast_nullable_to_non_nullable
              as Anchor?,
      trailer: freezed == trailer
          ? _value.trailer
          : trailer // ignore: cast_nullable_to_non_nullable
              as String?,
      toPut: null == toPut
          ? _value._toPut
          : toPut // ignore: cast_nullable_to_non_nullable
              as List<AnimeDataResponseDTO>,
      schedule: freezed == schedule
          ? _value.schedule
          : schedule // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AnimeDetailDTOImpl extends _AnimeDetailDTO {
  const _$AnimeDetailDTOImpl(
      {required this.name,
      required this.othername,
      required this.image,
      required this.poster,
      this.pathToView,
      required this.description,
      required this.rate,
      required this.countRate,
      required this.duration,
      required this.yearOf,
      required this.views,
      required final List<Anchor> season,
      required final List<Anchor> genre,
      required this.quality,
      required this.status,
      required final List<Anchor> authors,
      required final List<Anchor> countries,
      required this.follows,
      required this.language,
      required this.studio,
      this.seasonOf,
      this.trailer,
      required final List<AnimeDataResponseDTO> toPut,
      this.schedule})
      : _season = season,
        _genre = genre,
        _authors = authors,
        _countries = countries,
        _toPut = toPut,
        super._();

  factory _$AnimeDetailDTOImpl.fromJson(Map<String, dynamic> json) =>
      _$$AnimeDetailDTOImplFromJson(json);

  @override
  final String name;
  @override
  final String othername;
  @override
  final String image;
  @override
  final String poster;
  @override
  final String? pathToView;
  @override
  final String description;
  @override
  final double rate;
  @override
  final int countRate;
  @override
  final String duration;
  @override
  final int yearOf;
  @override
  final int views;
  final List<Anchor> _season;
  @override
  List<Anchor> get season {
    if (_season is EqualUnmodifiableListView) return _season;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_season);
  }

  final List<Anchor> _genre;
  @override
  List<Anchor> get genre {
    if (_genre is EqualUnmodifiableListView) return _genre;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_genre);
  }

  @override
  final String quality;
  @override
  final String status;
  final List<Anchor> _authors;
  @override
  List<Anchor> get authors {
    if (_authors is EqualUnmodifiableListView) return _authors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_authors);
  }

  final List<Anchor> _countries;
  @override
  List<Anchor> get countries {
    if (_countries is EqualUnmodifiableListView) return _countries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_countries);
  }

  @override
  final int follows;
  @override
  final String language;
  @override
  final String studio;
  @override
  final Anchor? seasonOf;
  @override
  final String? trailer;
  final List<AnimeDataResponseDTO> _toPut;
  @override
  List<AnimeDataResponseDTO> get toPut {
    if (_toPut is EqualUnmodifiableListView) return _toPut;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_toPut);
  }

  @override
  final String? schedule;

  /// Create a copy of AnimeDetailDTO
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnimeDetailDTOImplCopyWith<_$AnimeDetailDTOImpl> get copyWith =>
      __$$AnimeDetailDTOImplCopyWithImpl<_$AnimeDetailDTOImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AnimeDetailDTOImplToJson(
      this,
    );
  }
}

abstract class _AnimeDetailDTO extends AnimeDetailDTO {
  const factory _AnimeDetailDTO(
      {required final String name,
      required final String othername,
      required final String image,
      required final String poster,
      final String? pathToView,
      required final String description,
      required final double rate,
      required final int countRate,
      required final String duration,
      required final int yearOf,
      required final int views,
      required final List<Anchor> season,
      required final List<Anchor> genre,
      required final String quality,
      required final String status,
      required final List<Anchor> authors,
      required final List<Anchor> countries,
      required final int follows,
      required final String language,
      required final String studio,
      final Anchor? seasonOf,
      final String? trailer,
      required final List<AnimeDataResponseDTO> toPut,
      final String? schedule}) = _$AnimeDetailDTOImpl;
  const _AnimeDetailDTO._() : super._();

  factory _AnimeDetailDTO.fromJson(Map<String, dynamic> json) =
      _$AnimeDetailDTOImpl.fromJson;

  @override
  String get name;
  @override
  String get othername;
  @override
  String get image;
  @override
  String get poster;
  @override
  String? get pathToView;
  @override
  String get description;
  @override
  double get rate;
  @override
  int get countRate;
  @override
  String get duration;
  @override
  int get yearOf;
  @override
  int get views;
  @override
  List<Anchor> get season;
  @override
  List<Anchor> get genre;
  @override
  String get quality;
  @override
  String get status;
  @override
  List<Anchor> get authors;
  @override
  List<Anchor> get countries;
  @override
  int get follows;
  @override
  String get language;
  @override
  String get studio;
  @override
  Anchor? get seasonOf;
  @override
  String? get trailer;
  @override
  List<AnimeDataResponseDTO> get toPut;
  @override
  String? get schedule;

  /// Create a copy of AnimeDetailDTO
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnimeDetailDTOImplCopyWith<_$AnimeDetailDTOImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
