// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'anime_data_response_dto.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AnimeDataResponseDTO _$AnimeDataResponseDTOFromJson(Map<String, dynamic> json) {
  return _AnimeDataResponseDTO.fromJson(json);
}

/// @nodoc
mixin _$AnimeDataResponseDTO {
  String get path => throw _privateConstructorUsedError;
  String get image => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get chap => throw _privateConstructorUsedError;
  double? get rate => throw _privateConstructorUsedError;
  int? get views => throw _privateConstructorUsedError;
  String get quality => throw _privateConstructorUsedError;
  String? get process => throw _privateConstructorUsedError;
  int get year => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  String? get studio => throw _privateConstructorUsedError;
  List<Map<String, String>>? get genre => throw _privateConstructorUsedError;
  int? get timeRelease => throw _privateConstructorUsedError;

  /// Serializes this AnimeDataResponseDTO to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AnimeDataResponseDTO
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AnimeDataResponseDTOCopyWith<AnimeDataResponseDTO> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnimeDataResponseDTOCopyWith<$Res> {
  factory $AnimeDataResponseDTOCopyWith(AnimeDataResponseDTO value,
          $Res Function(AnimeDataResponseDTO) then) =
      _$AnimeDataResponseDTOCopyWithImpl<$Res, AnimeDataResponseDTO>;
  @useResult
  $Res call(
      {String path,
      String image,
      String name,
      String chap,
      double? rate,
      int? views,
      String quality,
      String? process,
      int year,
      String description,
      String? studio,
      List<Map<String, String>>? genre,
      int? timeRelease});
}

/// @nodoc
class _$AnimeDataResponseDTOCopyWithImpl<$Res,
        $Val extends AnimeDataResponseDTO>
    implements $AnimeDataResponseDTOCopyWith<$Res> {
  _$AnimeDataResponseDTOCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnimeDataResponseDTO
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? image = null,
    Object? name = null,
    Object? chap = null,
    Object? rate = freezed,
    Object? views = freezed,
    Object? quality = null,
    Object? process = freezed,
    Object? year = null,
    Object? description = null,
    Object? studio = freezed,
    Object? genre = freezed,
    Object? timeRelease = freezed,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chap: null == chap
          ? _value.chap
          : chap // ignore: cast_nullable_to_non_nullable
              as String,
      rate: freezed == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as double?,
      views: freezed == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String,
      process: freezed == process
          ? _value.process
          : process // ignore: cast_nullable_to_non_nullable
              as String?,
      year: null == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      studio: freezed == studio
          ? _value.studio
          : studio // ignore: cast_nullable_to_non_nullable
              as String?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as List<Map<String, String>>?,
      timeRelease: freezed == timeRelease
          ? _value.timeRelease
          : timeRelease // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnimeDataResponseDTOImplCopyWith<$Res>
    implements $AnimeDataResponseDTOCopyWith<$Res> {
  factory _$$AnimeDataResponseDTOImplCopyWith(_$AnimeDataResponseDTOImpl value,
          $Res Function(_$AnimeDataResponseDTOImpl) then) =
      __$$AnimeDataResponseDTOImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String path,
      String image,
      String name,
      String chap,
      double? rate,
      int? views,
      String quality,
      String? process,
      int year,
      String description,
      String? studio,
      List<Map<String, String>>? genre,
      int? timeRelease});
}

/// @nodoc
class __$$AnimeDataResponseDTOImplCopyWithImpl<$Res>
    extends _$AnimeDataResponseDTOCopyWithImpl<$Res, _$AnimeDataResponseDTOImpl>
    implements _$$AnimeDataResponseDTOImplCopyWith<$Res> {
  __$$AnimeDataResponseDTOImplCopyWithImpl(_$AnimeDataResponseDTOImpl _value,
      $Res Function(_$AnimeDataResponseDTOImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnimeDataResponseDTO
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? image = null,
    Object? name = null,
    Object? chap = null,
    Object? rate = freezed,
    Object? views = freezed,
    Object? quality = null,
    Object? process = freezed,
    Object? year = null,
    Object? description = null,
    Object? studio = freezed,
    Object? genre = freezed,
    Object? timeRelease = freezed,
  }) {
    return _then(_$AnimeDataResponseDTOImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      chap: null == chap
          ? _value.chap
          : chap // ignore: cast_nullable_to_non_nullable
              as String,
      rate: freezed == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as double?,
      views: freezed == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int?,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String,
      process: freezed == process
          ? _value.process
          : process // ignore: cast_nullable_to_non_nullable
              as String?,
      year: null == year
          ? _value.year
          : year // ignore: cast_nullable_to_non_nullable
              as int,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      studio: freezed == studio
          ? _value.studio
          : studio // ignore: cast_nullable_to_non_nullable
              as String?,
      genre: freezed == genre
          ? _value._genre
          : genre // ignore: cast_nullable_to_non_nullable
              as List<Map<String, String>>?,
      timeRelease: freezed == timeRelease
          ? _value.timeRelease
          : timeRelease // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AnimeDataResponseDTOImpl extends _AnimeDataResponseDTO {
  const _$AnimeDataResponseDTOImpl(
      {required this.path,
      required this.image,
      required this.name,
      required this.chap,
      this.rate,
      this.views,
      required this.quality,
      this.process,
      required this.year,
      required this.description,
      this.studio,
      final List<Map<String, String>>? genre,
      this.timeRelease})
      : _genre = genre,
        super._();

  factory _$AnimeDataResponseDTOImpl.fromJson(Map<String, dynamic> json) =>
      _$$AnimeDataResponseDTOImplFromJson(json);

  @override
  final String path;
  @override
  final String image;
  @override
  final String name;
  @override
  final String chap;
  @override
  final double? rate;
  @override
  final int? views;
  @override
  final String quality;
  @override
  final String? process;
  @override
  final int year;
  @override
  final String description;
  @override
  final String? studio;
  final List<Map<String, String>>? _genre;
  @override
  List<Map<String, String>>? get genre {
    final value = _genre;
    if (value == null) return null;
    if (_genre is EqualUnmodifiableListView) return _genre;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? timeRelease;

  /// Create a copy of AnimeDataResponseDTO
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnimeDataResponseDTOImplCopyWith<_$AnimeDataResponseDTOImpl>
      get copyWith =>
          __$$AnimeDataResponseDTOImplCopyWithImpl<_$AnimeDataResponseDTOImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AnimeDataResponseDTOImplToJson(
      this,
    );
  }
}

abstract class _AnimeDataResponseDTO extends AnimeDataResponseDTO {
  const factory _AnimeDataResponseDTO(
      {required final String path,
      required final String image,
      required final String name,
      required final String chap,
      final double? rate,
      final int? views,
      required final String quality,
      final String? process,
      required final int year,
      required final String description,
      final String? studio,
      final List<Map<String, String>>? genre,
      final int? timeRelease}) = _$AnimeDataResponseDTOImpl;
  const _AnimeDataResponseDTO._() : super._();

  factory _AnimeDataResponseDTO.fromJson(Map<String, dynamic> json) =
      _$AnimeDataResponseDTOImpl.fromJson;

  @override
  String get path;
  @override
  String get image;
  @override
  String get name;
  @override
  String get chap;
  @override
  double? get rate;
  @override
  int? get views;
  @override
  String get quality;
  @override
  String? get process;
  @override
  int get year;
  @override
  String get description;
  @override
  String? get studio;
  @override
  List<Map<String, String>>? get genre;
  @override
  int? get timeRelease;

  /// Create a copy of AnimeDataResponseDTO
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnimeDataResponseDTOImplCopyWith<_$AnimeDataResponseDTOImpl>
      get copyWith => throw _privateConstructorUsedError;
}
